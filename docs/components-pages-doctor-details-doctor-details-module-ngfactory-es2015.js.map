{"version":3,"sources":["./src/app/components/pages/doctor-details/doctor-details.component.ts","./src/app/components/pages/doctor-details/content/content.component.html","./src/app/components/pages/doctor-details/doctor-details-routing.module.ts","./src/app/components/pages/doctor-details/doctor-details.module.ts","./node_modules/ngx-page-scroll/fesm2015/ngx-page-scroll.js","./src/app/components/shared/fab-button/fab-button.component.html","./node_modules/ngx-page-scroll-core/fesm2015/ngx-page-scroll-core.js","./src/app/components/pages/doctor-details/doctor-details.component.html","./src/app/components/shared/fab-button/fab-button.component.ts","./src/app/components/helper/doctor/doctor-helper.service.ts","./src/app/components/pages/doctor-details/content/content.component.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAO,MAAM,sBAAsB;IAEjC,gBAAgB,CAAC;IAEjB,QAAQ;IACR,CAAC;CAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sGCdD,+JA0EM,KAzEF,8IAwEM,KAvEF,wIA4CM,KA3CF,8IA0CM,KAzCF,6JAwCM,KAvCF,kJAsCM,KArCF,6JAgCM,KA/BF,mJA8BM,KA7BF,4IAIM,KAHF,oJAEM,KADF,kJAA0C,KAGlD,8IAuBM,KAtBF,qJAqBM,KApBF,uHAEK,KAFD,8EAEJ,MACA,0JAEM,KAF6B,8EAEnC,MACA,yJAaM,KAZF,yHAGO,KAFH,+IAA4B,mFAEhC,MACA,yHAGO,KAFH,4IAAyB,mFAE7B,MACA,yHAGO,KAFH,kJAA+B,mFAEnC,MAMpB,6JAGM,KAFF,uHAA4B,KAAxB,kFAAmB,MACvB,yIAAuC,KAM3D,0LAyBM,KAvBF,8IAkBM,KAjBF,mLAgBM,KAfF,sJAWM,KAVF,iKAGM,KAFF,yLAA4D,KAC5D,8KAA8D,KAElE,uJAKM,KAJF,uHAEK,KAFD,0FAEJ,MACA,gKAAwD,KAAf,qFAAQ,MAGzD,2JAEM,KADF,uIAA6G,KAA7F,6KAAyF,MAIrH,8JAEM,KADF,6MAAgF,gCA3DnD,kBAAkB,0BAAC,kBAAiB,yBAAzC,aAA0C,EAArC,SAAkB,EAAC,SAAiB,GAKrC,mEAEJ,GACmC,yEAEnC,GAGoC,oEAEhC,GAE6B,oEAE7B,GAEmC,uEAEnC,GAOZ,mEAAmB,GAClB,kBAA2B,6BAAhC,aAAuC,EAAlC,SAA2B;sGAzC5D,kdA0EM,iDA1EkC,mBAAkC,gBAA1E,YA0EM,EA1EkC,SAAkC;;;;;;;;;;;;;;;;ACE1E;AAAA;AAAA;AAAoE;AAEpE,MAAM,MAAM,GAAW,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,SAAS,EAAE,gFAAsB,EAAE,CAAC,CAAC;AAMlE,MAAM,0BAA0B;CAAI;;;;;;;;;;;;;ACe3C;AAAA;AAAO,MAAM,mBAAmB;CAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmG;AACjB;AACS;AAChD;AACG;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAM;AAC9C;AACA,kDAAkD,6DAAa,2BAA2B,+DAAe;AACzG,kDAAkD,gEAAgB;AAClE,iBAAiB;AACjB;AACA,gBAAgB,2DAAI;AACpB,+CAA+C,6DAAa;AAC5D;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,6BAA6B;AAC7B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,KAAK,OAAO,sEAAiB,EAAE;AAC/B,KAAK,OAAO,sDAAM,gBAAgB,OAAO,sDAAQ,EAAE,GAAG;AACtD,KAAK,gCAAgC,OAAO,oDAAM,SAAS,wDAAQ,IAAI;AACvE;AACA;AACA,kBAAkB,OAAO,mDAAK,EAAE;AAChC,YAAY,OAAO,mDAAK,EAAE;AAC1B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,wBAAwB,OAAO,mDAAK,EAAE;AACtC,4BAA4B,OAAO,mDAAK,EAAE;AAC1C,wBAAwB,OAAO,mDAAK,EAAE;AACtC,0BAA0B,OAAO,mDAAK,EAAE;AACxC,uBAAuB,OAAO,mDAAK,EAAE;AACrC,wBAAwB,OAAO,mDAAK,EAAE;AACtC,+BAA+B,OAAO,mDAAK,EAAE;AAC7C,wBAAwB,OAAO,mDAAK,EAAE;AACtC,4BAA4B,OAAO,mDAAK,EAAE;AAC1C,kBAAkB,OAAO,mDAAK,EAAE;AAChC,wBAAwB,OAAO,oDAAM,EAAE;AACvC;;AAEA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA;AACA;AACA,oBAAoB,4EAAuB;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEuD;AACvD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wGCvKA,+IAQQ,KAPJ,wKAMQ,KALJ,gJAIO,KAHH,+KAEI,KADA,0JAAwC,wDADzC,mBAAoB,cAAvB,YAEI,EAFD,SAAoB;;;;;;;;;;;;;;;;ACHnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsH;;AAEtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,0BAA0B;AAC1B;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,4DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,0FAA0F,yBAAyB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA,6EAA6E,+DAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,+DAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,+DAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,+DAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+DAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAkB,EAAE,gDAAgD,8BAA8B,8DAAQ,gBAAgB,EAAE,gDAAgD;AACtM;AACA,KAAK,OAAO,wDAAU;AACtB;AACA,aAAa;AACb;AACA;AACA,KAAK,gCAAgC,OAAO,oDAAM,yBAAyB;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0CAA0C;AACtF;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA,qBAAqB,wCAAwC;AAC7D;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEiH;AACjH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4GCheA;;;8eAAiC,IACjC,shBAAmC,IACnC,whBAA2B,IAC3B,gnBAAyB,IACzB,olBAAiC,yBAJjC,YAAiC,GACjC,YAAmC,GACnC,YAA2B,GAC3B,YAAyB,GACzB,YAAiC;;;;;;;;;;;;;;;;ACIjC;AAAA;AAAO,MAAM,kBAAkB;IAI7B,YAAoB,eAAgC;QAAhC,oBAAe,GAAf,eAAe,CAAiB;QAFpD,gBAAW,GAAG,EAAE,CAAC;IAEuC,CAAC;IAEzD,QAA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","file":"components-pages-doctor-details-doctor-details-module-ngfactory-es2015.js","sourcesContent":["import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-doctor-details',\r\n  templateUrl: './doctor-details.component.html',\r\n  styleUrls: ['./doctor-details.component.css']\r\n})\r\nexport class DoctorDetailsComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n","<div class=\"section sigma_post-details\" *ngFor=\"let item of doctordetails\">\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div class=\"col-lg-12\">\r\n                <div class=\"sigma_post-details-inner\">\r\n                    <div class=\"entry-content\">\r\n                        <div class=\"sigma_team style-17 mb-0\">\r\n                            <div class=\"row no-gutters\">\r\n                                <div class=\"col-md-4\">\r\n                                    <div class=\"sigma_team-thumb\">\r\n                                        <img [src]=\"item.image\" [alt]=\"item.name\">\r\n                                    </div>\r\n                                </div>\r\n                                <div class=\"col-md-8\">\r\n                                    <div class=\"sigma_team-body\">\r\n                                        <h5>\r\n                                            {{item.name}}\r\n                                        </h5>\r\n                                        <div class=\"sigma_team-categories\">\r\n                                            {{item.specialist}}\r\n                                        </div>\r\n                                        <div class=\"sigma_team-info mt-4\">\r\n                                            <span>\r\n                                                <i class=\"fal fa-phone\"></i>\r\n                                                {{item.phone}}\r\n                                            </span>\r\n                                            <span>\r\n                                                <i class=\"fal fa-at\"></i>\r\n                                                {{item.email}}\r\n                                            </span>\r\n                                            <span>\r\n                                                <i class=\"fal fa-building\"></i>\r\n                                                {{item.location}}\r\n                                            </span>\r\n                                        </div>\r\n                                    </div>\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        <div class=\"my-5\" id=\"overview\">\r\n                            <h4>Sobre {{item.name}}</h4>\r\n                            <div [innerHtml]=\"item.htmltext\"></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"row d-flex justify-content-center align-items-center\">\r\n            <!-- Data -->\r\n            <div class=\"col-md-6\">\r\n                <div class=\"sigma_testimonial style-13 text-left bg-white\">\r\n                    <div class=\"sigma_author-info\">\r\n                        <div class=\"sigma_testimonial-thumb mr-4\">\r\n                            <img src=\"assets/img/LOGO-3.jpg\" alt=\"Dr. William Raymundo\">\r\n                            <span class=\"fas fa-quote-left sigma_testimonial-icon\"></span>\r\n                        </div>\r\n                        <div class=\"sigma_author-block\">\r\n                            <h5>\r\n                                Aristóteles\r\n                            </h5>\r\n                            <span class=\"sigma_testimonial-category\">Filósofo</span>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"sigma_testimonial-body\">\r\n                        <p class=\"mb-0\">\"Somos lo que hacemos día a día. De modo que la excelencia no es un acto sino un habito.\"</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-6 sigma_team-thumb\">\r\n                <img src=\"assets/img/home-2/dr-william-raymundo.jpeg\" alt=\"Dr.William Raymundo\">\r\n            </div>\r\n            <!-- Data -->\r\n        </div>\r\n    </div>\r\n</div>","import { NgModule } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\nimport { DoctorDetailsComponent } from './doctor-details.component';\r\n\r\nconst routes: Routes = [{ path: '', component: DoctorDetailsComponent }];\r\n\r\n@NgModule({\r\n  imports: [RouterModule.forChild(routes)],\r\n  exports: [RouterModule]\r\n})\r\nexport class DoctorDetailsRoutingModule { }\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { NgbModule } from '@ng-bootstrap/ng-bootstrap';\r\nimport { NgxPageScrollCoreModule } from 'ngx-page-scroll-core';\r\nimport { NgxPageScrollModule } from 'ngx-page-scroll';\r\n\r\nimport { DoctorDetailsRoutingModule } from './doctor-details-routing.module';\r\nimport { DoctorDetailsComponent } from './doctor-details.component';\r\nimport { SharedModule } from '../../shared/shared.module';\r\nimport { ContentComponent } from './content/content.component';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    DoctorDetailsComponent,\r\n    ContentComponent\r\n  ],\r\n  imports: [\r\n    CommonModule,\r\n    DoctorDetailsRoutingModule,\r\n    SharedModule,\r\n    NgbModule,\r\n    NgxPageScrollCoreModule,\r\n    NgxPageScrollModule\r\n  ]\r\n})\r\nexport class DoctorDetailsModule { }\r\n","import { EventEmitter, Directive, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { PageScrollService, NgxPageScrollCoreModule } from 'ngx-page-scroll-core';\nimport { NavigationEnd, NavigationError, NavigationCancel, Router } from '@angular/router';\nimport { DOCUMENT } from '@angular/common';\nimport { filter, take } from 'rxjs/operators';\n\n/* tslint:disable:no-host-metadata-property directive-selector */\nclass NgxPageScrollDirective {\n    constructor(pageScrollService, router, document) {\n        this.pageScrollService = pageScrollService;\n        this.router = router;\n        this.pageScrollAdjustHash = false;\n        this.pageScrollFinish = new EventEmitter();\n        this.document = document;\n    }\n    ngOnChanges(changes) {\n        // Some inputs changed, reset the pageScrollInstance\n        this.pageScrollInstance = undefined;\n    }\n    ngOnDestroy() {\n        if (this.pageScrollInstance) {\n            this.pageScrollService.stop(this.pageScrollInstance);\n        }\n    }\n    getPageScrollTarget() {\n        return this.pageScrollTarget || this.href || (this.fragment ? '#' + this.fragment : '');\n    }\n    generatePageScrollInstance() {\n        if (this.pageScrollInstance === undefined || this.pageScrollInstance === null) {\n            const options = {\n                document: this.document,\n                scrollTarget: this.getPageScrollTarget(),\n            };\n            if (this.pageScroll) {\n                options.namespace = this.pageScroll;\n            }\n            if (this.pageScrollHorizontal !== undefined && this.pageScrollHorizontal !== null) {\n                options.verticalScrolling = !this.pageScrollHorizontal;\n            }\n            if (this.pageScrollOffset !== undefined && this.pageScrollOffset !== null) {\n                options.scrollOffset = this.pageScrollOffset;\n            }\n            if (this.pageScrollInterruptible !== undefined && this.pageScrollInterruptible !== null) {\n                options.interruptible = this.pageScrollInterruptible;\n            }\n            if (this.pageScrollInView !== undefined && this.pageScrollInView !== null) {\n                options.scrollInView = this.pageScrollInView;\n            }\n            if (this.pageScrollEasing) {\n                options.easingLogic = this.pageScrollEasing;\n            }\n            if (this.pageScrollDuration !== undefined && this.pageScrollDuration !== null) {\n                options.duration = this.pageScrollDuration;\n            }\n            if (this.pageScrollSpeed !== undefined && this.pageScrollSpeed !== null) {\n                options.speed = this.pageScrollSpeed;\n            }\n            if (this.pageScrollFinish) {\n                options.scrollFinishListener = this.pageScrollFinish;\n            }\n            this.pageScrollInstance = this.pageScrollService.create(options);\n        }\n        return this.pageScrollInstance;\n    }\n    pushRouterState() {\n        if (this.pageScrollAdjustHash && typeof this.pageScrollInstance.pageScrollOptions.scrollTarget === 'string'\n            && this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(0, 1) === '#') {\n            // \"Navigate\" to the current route again and this time set the fragment/hash\n            this.router.navigate([], {\n                fragment: this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(1),\n                queryParamsHandling: 'preserve',\n            });\n        }\n    }\n    scroll() {\n        const pageScrollInstance = this.generatePageScrollInstance();\n        this.pushRouterState();\n        this.pageScrollService.start(pageScrollInstance);\n    }\n    handleClick(clickEvent) {\n        if (this.routerLink && this.router !== null && this.router !== undefined) {\n            let urlTree;\n            if (typeof this.routerLink === 'string') {\n                urlTree = this.router.parseUrl(this.routerLink);\n            }\n            else {\n                urlTree = this.router.createUrlTree(this.routerLink);\n            }\n            if (!this.router.isActive(urlTree, true)) {\n                // We need to navigate their first.\n                // Navigation is handled by the routerLink directive so we only need to listen for route change\n                this.router.events.pipe(filter(routerEvent => {\n                    // We're only interested in successful navigations or when the navigation fails\n                    return routerEvent instanceof NavigationEnd || routerEvent instanceof NavigationError\n                        || routerEvent instanceof NavigationCancel;\n                }), \n                // Consume only one event, automatically \"unsubscribing\" from the event stream afterwards\n                take(1)).subscribe((routerEvent) => {\n                    if (routerEvent instanceof NavigationEnd) {\n                        // use a timeout to start scrolling as soon as the stack is cleared\n                        setTimeout(() => {\n                            this.scroll();\n                        }, 0);\n                    }\n                });\n                return false; // to preventDefault()\n            }\n        }\n        this.scroll();\n        return false; // to preventDefault()\n    }\n}\nNgxPageScrollDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[pageScroll]',\n                host: {\n                    '(click)': 'handleClick($event)',\n                },\n            },] }\n];\nNgxPageScrollDirective.ctorParameters = () => [\n    { type: PageScrollService },\n    { type: Router, decorators: [{ type: Optional }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nNgxPageScrollDirective.propDecorators = {\n    routerLink: [{ type: Input }],\n    href: [{ type: Input }],\n    fragment: [{ type: Input }],\n    pageScrollTarget: [{ type: Input }],\n    pageScrollHorizontal: [{ type: Input }],\n    pageScrollOffset: [{ type: Input }],\n    pageScrollDuration: [{ type: Input }],\n    pageScrollSpeed: [{ type: Input }],\n    pageScrollEasing: [{ type: Input }],\n    pageScrollInterruptible: [{ type: Input }],\n    pageScrollInView: [{ type: Input }],\n    pageScrollAdjustHash: [{ type: Input }],\n    pageScroll: [{ type: Input }],\n    pageScrollFinish: [{ type: Output }]\n};\n\nclass NgxPageScrollModule {\n}\nNgxPageScrollModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    NgxPageScrollDirective,\n                ],\n                imports: [\n                    NgxPageScrollCoreModule,\n                ],\n                exports: [\n                    NgxPageScrollDirective,\n                ],\n            },] }\n];\n\n/*\n * Public API Surface of ngx-page-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxPageScrollDirective, NgxPageScrollModule };\n//# sourceMappingURL=ngx-page-scroll.js.map\n","<div class=\"fab-wrapper\">\n    <label class=\"fab-button\" for=\"fabCheckbox\">\n        <span class=\"fab-content\">\n            <a [href]=\"whatsAppUrl\" target=\"_blank\" class=\"fab-content\">\n                <i class=\"fab fa-whatsapp icon-fab\"></i>\n            </a>\n        </span>\n    </label>\n  </div>","import { InjectionToken, isDevMode, ɵɵdefineInjectable, ɵɵinject, Injectable, Inject, NgModule } from '@angular/core';\n\n/**\n * Represents a scrolling action\n */\nclass PageScrollInstance {\n    /**\n     * Private constructor, requires the properties assumed to be the bare minimum.\n     * Use the factory methods to create instances:\n     *      {@link PageScrollService#create}\n     */\n    constructor(pageScrollOptions) {\n        /**\n         * These properties will be set/manipulated if the scroll animation starts\n         */\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n        this.startScrollPosition = 0;\n        /* Whether an interrupt listener is attached to the body or not */\n        this.interruptListenersAttached = false;\n        /* References to the timer instance that is used to perform the scroll animation to be\n         able to clear it on animation end*/\n        this.timer = null;\n        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n            pageScrollOptions.scrollViews = [\n                pageScrollOptions.document.documentElement,\n                pageScrollOptions.document.body,\n                pageScrollOptions.document.body.parentNode,\n            ];\n            this.isInlineScrolling = false;\n        }\n        else {\n            this.isInlineScrolling = true;\n        }\n        this.pageScrollOptions = pageScrollOptions;\n    }\n    static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const body = pageScrollOptions.document.body;\n        const docEl = pageScrollOptions.document.documentElement;\n        const windowPageYOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageYOffset || undefined;\n        const windowPageXOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageXOffset || undefined;\n        const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n        const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n        const clientTop = docEl.clientTop || body.clientTop || 0;\n        const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n        if (scrollTargetElement === undefined || scrollTargetElement === null) {\n            // No element found, so return the current position to not cause any change in scroll position\n            return { top: scrollTop, left: scrollLeft };\n        }\n        const box = scrollTargetElement.getBoundingClientRect();\n        const top = box.top + scrollTop - clientTop;\n        const left = box.left + scrollLeft - clientLeft;\n        return { top: Math.round(top), left: Math.round(left) };\n    }\n    static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {\n        const position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\n        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n            const accumulatedParentsPos = { top: 0, left: 0 };\n            // not named window to make sure we're not getting the global window variable by accident\n            const theWindow = scrollTargetElement.ownerDocument.defaultView;\n            let parentFound = false;\n            // Start parent is the immediate parent\n            let parent = scrollTargetElement.parentElement;\n            // Iterate upwards all parents\n            while (!parentFound && parent !== undefined && parent !== null) {\n                if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\n                    accumulatedParentsPos.top += parent.offsetTop;\n                    accumulatedParentsPos.left += parent.offsetLeft;\n                }\n                // Next iteration\n                parent = parent.parentElement;\n                parentFound = parent === pageScrollOptions.scrollViews[0];\n            }\n            if (parentFound) {\n                // Only use the results if we found the parent, otherwise we accumulated too much anyway\n                position.top += accumulatedParentsPos.top;\n                position.left += accumulatedParentsPos.left;\n            }\n            else {\n                /* TODO Uncomment\n                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                  console.warn('Unable to find nested scrolling targets parent!');\n                }*/\n            }\n        }\n        return position;\n    }\n    getScrollPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.scrollLeft;\n        }\n        return scrollingView.scrollTop;\n    }\n    getScrollClientPropertyValue(scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.clientWidth;\n        }\n        return scrollingView.clientHeight;\n    }\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     */\n    extractScrollTargetPosition() {\n        const scrollTargetElement = this.getScrollTargetElement();\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\n            // Scroll target not found\n            return { top: NaN, left: NaN };\n        }\n        if (this.isInlineScrolling) {\n            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n        }\n        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    }\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     */\n    getCurrentOffset() {\n        return this.pageScrollOptions.scrollOffset;\n    }\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    setScrollPosition(position) {\n        // Set the new scrollTop/scrollLeft to all scrollViews elements\n        return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {\n            const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\n            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n                const scrollDistance = Math.abs(startScrollPropertyValue - position);\n                // The movement we need to perform is less than 2px\n                // This we consider a small movement which some browser may not perform when\n                // changing the scrollTop/scrollLeft property\n                // Thus in this cases we do not stop the scroll animation, although setting the\n                // scrollTop/scrollLeft value \"fails\"\n                const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;\n                if (!this.pageScrollOptions.verticalScrolling) {\n                    scrollingView.scrollLeft = position;\n                }\n                else {\n                    scrollingView.scrollTop = position;\n                }\n                // Return true if setting the new scrollTop/scrollLeft value worked\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n                // set due to dpi or rounding irregularities)\n                if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\n                    return true;\n                }\n            }\n            return oneAlreadyWorked;\n        }, false);\n    }\n    /**\n     * Trigger firing a animation finish event\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\n     */\n    fireEvent(value) {\n        if (this.pageScrollOptions.scrollFinishListener) {\n            this.pageScrollOptions.scrollFinishListener.emit(value);\n        }\n    }\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     */\n    attachInterruptListeners(interruptReporter) {\n        if (this.interruptListenersAttached) {\n            // Detach possibly existing listeners first\n            this.detachInterruptListeners();\n        }\n        this.interruptListener = (event) => {\n            interruptReporter.report(event, this);\n        };\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = true;\n    }\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     */\n    detachInterruptListeners() {\n        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));\n        this.interruptListenersAttached = false;\n    }\n    getScrollTargetElement() {\n        if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n            const targetSelector = this.pageScrollOptions.scrollTarget;\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n                // It's an id selector and a valid id, as it does not contain any white space characters\n                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n            }\n            return this.pageScrollOptions.document.querySelector(targetSelector);\n        }\n        return this.pageScrollOptions.scrollTarget;\n    }\n}\n\nconst NGXPS_CONFIG = new InjectionToken('ngxps_config');\nconst ɵ0 = (t, b, c, d) => {\n    // Linear easing\n    return c * t / d + b;\n};\nconst defaultPageScrollConfig = {\n    _interval: 10,\n    _minScrollDistance: 2,\n    _logLevel: 1,\n    namespace: 'default',\n    verticalScrolling: true,\n    duration: 1250,\n    scrollOffset: 0,\n    advancedInlineOffsetCalculation: false,\n    interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n    interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n    interruptible: true,\n    scrollInView: true,\n    easingLogic: ɵ0,\n};\n\nclass PageScrollService {\n    constructor(customConfig) {\n        this.runningInstances = [];\n        this.onInterrupted = {\n            report: (event, pageScrollInstance) => {\n                if (!pageScrollInstance.pageScrollOptions.interruptible) {\n                    // Non-interruptible anyway, so do not stop anything\n                    return;\n                }\n                let shouldStop = true;\n                if (event.type === 'keyup') {\n                    // Only stop if specific keys have been pressed, for all others don't stop anything\n                    if (this.config.interruptKeys.indexOf(event.key) === -1) {\n                        // The pressed key is not in the list of interrupting keys\n                        shouldStop = false;\n                    }\n                }\n                else if (event.type === 'mousedown') {\n                    // For mousedown events we only stop the scroll animation of the mouse has\n                    // been clicked inside the scrolling container\n                    if (!pageScrollInstance.pageScrollOptions.scrollViews.some(scrollingView => scrollingView.contains(event.target))) {\n                        // Mouse clicked an element which is not inside any of the the scrolling containers\n                        shouldStop = false;\n                    }\n                }\n                if (shouldStop) {\n                    this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n                }\n            },\n        };\n        this.config = Object.assign(Object.assign({}, defaultPageScrollConfig), customConfig);\n    }\n    stopInternal(interrupted, pageScrollInstance) {\n        const index = this.runningInstances.indexOf(pageScrollInstance);\n        if (index >= 0) {\n            this.runningInstances.splice(index, 1);\n        }\n        if (pageScrollInstance.interruptListenersAttached) {\n            pageScrollInstance.detachInterruptListeners();\n        }\n        if (pageScrollInstance.timer) {\n            // Clear/Stop the timer\n            clearInterval(pageScrollInstance.timer);\n            // Clear the reference to this timer\n            pageScrollInstance.timer = undefined;\n            pageScrollInstance.fireEvent(!interrupted);\n            return true;\n        }\n        return false;\n    }\n    create(options) {\n        return new PageScrollInstance(Object.assign(Object.assign({}, this.config), options));\n    }\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    start(pageScrollInstance) {\n        // Merge the default options in the pageScrollInstance options\n        pageScrollInstance.pageScrollOptions = Object.assign(Object.assign({}, this.config), pageScrollInstance.pageScrollOptions);\n        // Stop all possibly running scroll animations in the same namespace\n        this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n            // No scrollViews specified, thus we can't animate anything\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n            }\n            return;\n        }\n        let startScrollPositionFound = false;\n        let scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]);\n        // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n        pageScrollInstance.startScrollPosition = 0;\n        // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n        pageScrollInstance.pageScrollOptions.scrollViews.forEach(scrollingView => {\n            if (scrollingView === undefined || scrollingView === null) {\n                return;\n            }\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\n            const scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n            if (!startScrollPositionFound && scrollPosition) {\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\n                // Return the scroll position value, as this will be our startScrollPosition\n                pageScrollInstance.startScrollPosition = scrollPosition;\n                startScrollPositionFound = true;\n                // Remember te scrollRange of this scrollingView\n                scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n            }\n        });\n        const pageScrollOffset = pageScrollInstance.getCurrentOffset();\n        // Calculate the target position that the scroll animation should go to\n        const scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n        // Calculate the distance we need to go in total\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\n            // We weren't able to find the target position, maybe the element does not exist?\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\n            }\n            pageScrollInstance.fireEvent(false);\n            return;\n        }\n        // We're at the final destination already\n        // OR we need to scroll down but are already at the end\n        // OR we need to scroll up but are at the top already\n        const allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;\n        // Check how long we need to scroll if a speed option is given\n        // Default executionDuration is the specified duration\n        pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;\n        // Maybe we need to pay attention to the speed option?\n        if ((pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null) &&\n            (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\n            pageScrollInstance.executionDuration =\n                Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n        }\n        // We should go there directly, as our \"animation\" would have one big step\n        // only anyway and this way we save the interval stuff\n        const tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n        if (allReadyAtDestination || tooShortInterval) {\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                if (allReadyAtDestination) {\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n                }\n                else {\n                    console.log('Scroll duration shorter that interval length, jumping to target');\n                }\n            }\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n            pageScrollInstance.fireEvent(true);\n            return;\n        }\n        if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n            const alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition &&\n                pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n            if (alreadyInView) {\n                if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                    console.log('Not scrolling, as target already in view');\n                }\n                pageScrollInstance.fireEvent(true);\n                return;\n            }\n        }\n        // Register the interrupt listeners if we want an interruptible scroll animation\n        if (pageScrollInstance.pageScrollOptions.interruptible) {\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n        }\n        // Let's get started, get the start time...\n        pageScrollInstance.startTime = new Date().getTime();\n        // .. and calculate the end time (when we need to finish at last)\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n        pageScrollInstance.timer = setInterval((instance) => {\n            // Take the current time\n            const currentTime = new Date().getTime();\n            // Determine the new scroll position\n            let newScrollPosition;\n            let stopNow = false;\n            if (instance.endTime <= currentTime) {\n                // We're over the time already, so go the targetScrollPosition (aka destination)\n                newScrollPosition = instance.targetScrollPosition;\n                stopNow = true;\n            }\n            else {\n                // Calculate the scroll position based on the current time using the easing function\n                newScrollPosition = Math.round(instance.pageScrollOptions.easingLogic(currentTime - instance.startTime, instance.startScrollPosition, instance.distanceToScroll, instance.executionDuration));\n            }\n            if (this.config._logLevel >= 5 && isDevMode()) {\n                console.warn('Scroll Position: ' + newScrollPosition);\n            }\n            // Set the new scrollPosition to all scrollViews elements\n            if (!instance.setScrollPosition(newScrollPosition)) {\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n                // early stop the scroll animation to save resources\n                stopNow = true;\n            }\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\n            // (otherwise the event might arrive at \"too early\")\n            if (stopNow) {\n                this.stopInternal(false, instance);\n            }\n        }, this.config._interval, pageScrollInstance);\n        // Register the instance as running one\n        this.runningInstances.push(pageScrollInstance);\n    }\n    scroll(options) {\n        this.start(this.create(options));\n    }\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     */\n    stopAll(namespace) {\n        if (this.runningInstances.length > 0) {\n            let stoppedSome = false;\n            for (let i = 0; i < this.runningInstances.length; ++i) {\n                const pageScrollInstance = this.runningInstances[i];\n                if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n                    stoppedSome = true;\n                    this.stopInternal(true, pageScrollInstance);\n                    // Decrease the counter, as we removed an item from the array we iterate over\n                    i--;\n                }\n            }\n            return stoppedSome;\n        }\n        return false;\n    }\n    stop(pageScrollInstance) {\n        return this.stopInternal(true, pageScrollInstance);\n    }\n}\nPageScrollService.ɵprov = ɵɵdefineInjectable({ factory: function PageScrollService_Factory() { return new PageScrollService(ɵɵinject(NGXPS_CONFIG)); }, token: PageScrollService, providedIn: \"root\" });\nPageScrollService.decorators = [\n    { type: Injectable, args: [{\n                providedIn: 'root',\n            },] }\n];\nPageScrollService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [NGXPS_CONFIG,] }] }\n];\n\nconst ɵ0$1 = {};\nclass NgxPageScrollCoreModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxPageScrollCoreModule,\n            providers: [PageScrollService, { provide: NGXPS_CONFIG, useValue: config }],\n        };\n    }\n}\nNgxPageScrollCoreModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [\n                    PageScrollService,\n                    { provide: NGXPS_CONFIG, useValue: ɵ0$1 },\n                ],\n            },] }\n];\n\n/*\n * Public API Surface of ngx-page-scroll-core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };\n//# sourceMappingURL=ngx-page-scroll-core.js.map\n","<app-header-two></app-header-two>\r\n<app-breadcrumbs></app-breadcrumbs>\r\n<app-content></app-content>\r\n<app-footer></app-footer>\r\n<app-fab-button></app-fab-button>","import { Component, OnInit } from '@angular/core';\nimport { WhatsappService } from '../../helper/whatsapp.service';\n\n@Component({\n  selector: 'app-fab-button',\n  templateUrl: './fab-button.component.html',\n  styleUrls: ['./fab-button.component.css']\n})\nexport class FabButtonComponent implements OnInit {\n\n  whatsAppUrl = '';\n\n  constructor(private whatsAppService: WhatsappService) { }\n\n  ngOnInit(): void {\n    this.whatsAppUrl = this.whatsAppService.getWhatsAppUrl();\n  }\n\n}\n","import { Injectable, AfterContentInit, OnInit } from '@angular/core';\r\nimport { ActivatedRoute } from '@angular/router';\r\nimport doctor from '../../data/doctor/doctor.json';\r\nimport category from '../../data/category.json';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class DoctorHelperService implements AfterContentInit, OnInit {\r\n  // pagination\r\n  page: number = 1;\r\n  // Doctor\r\n  public doctorblock = doctor;\r\n  public doctordetails = doctor;\r\n  // Category\r\n  public category = category;\r\n  public doctorcategory = category;\r\n  constructor(private router: ActivatedRoute) {}\r\n  // Add Heart\r\n  public favorite: boolean = false;\r\n  favoriteTrigger(item: { favorite: boolean; }) {\r\n    item.favorite = !item.favorite;\r\n  }\r\n  // Category\r\n  public getCategories(items: string | any[]) {\r\n    var elems = category.filter((item: { id: string; }) => {\r\n      return items.includes(item.id)\r\n    });\r\n    return elems;\r\n  }\r\n  // Author\r\n  public getAuthor(items: string | any[]) {\r\n    var elems = doctor.filter((item: { id: string; }) => {\r\n      return items.includes(item.id)\r\n    });\r\n    return elems;\r\n  }\r\n  // Doctor Details\r\n  public getDoctor(id: any) {\r\n    this.doctordetails = doctor.filter((item: { id: any; }) => { return item.id == id });\r\n  }\r\n  // Category Filter\r\n  public setCategory(id: any) {\r\n    this.doctorcategory = id;\r\n  }\r\n  public getCategory() {\r\n    return this.doctorcategory;\r\n  }\r\n  public getDoctorsByCategory(catId: string) {\r\n    return this.doctorblock = doctor.filter((item: { category: number[]; }) => { return item.category.includes(parseInt(catId)) });\r\n  }\r\n  // Fetch All filter\r\n  public setDoctors() {\r\n    var doctorsByCategory = this.getCategory() != undefined ? this.getDoctorsByCategory(this.getCategory()) : '';\r\n    if ((doctorsByCategory != '' || doctorsByCategory != undefined || doctorsByCategory != null) && doctorsByCategory.length > 0) {\r\n      this.doctorblock = doctorsByCategory;\r\n    } \r\n  }\r\n  ngAfterContentInit(): void {\r\n    this.setCategory(this.router.snapshot.params.catId);\r\n    this.setDoctors();\r\n    this.getDoctor(this.router.snapshot.params.id);\r\n  }\r\n  ngOnInit(): void {\r\n\r\n  }\r\n}\r\n","import { AfterContentInit, Component } from '@angular/core';\r\nimport { DoctorHelperService } from 'src/app/components/helper/doctor/doctor-helper.service';\r\n\r\n@Component({\r\n  selector: 'app-content',\r\n  templateUrl: './content.component.html',\r\n  styleUrls: ['./content.component.css']\r\n})\r\nexport class ContentComponent extends DoctorHelperService implements AfterContentInit {\r\n  ngAfterContentInit(){\r\n    this.setCategory(1);\r\n    this.setDoctors();\r\n    this.getDoctor(1);\r\n  }\r\n}\r\n"],"sourceRoot":"webpack:///"}